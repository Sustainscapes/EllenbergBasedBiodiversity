---
output:
  bookdown::github_document2:
    pandoc_args: --webtex
    fig_caption: true
    toc: true
bibliography: Biblio.bib
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  message = FALSE,
  warning = FALSE,
  error = FALSE
)
```

# Ellenberg Based Biodiversity

<!-- badges: start -->
<!-- badges: end -->

The goal of EllenbergBasedBiodiversity is to generate biodiversity metrics based on Ellenberg values extracted from [@tichy2023ellenberg], for this

## Environmental Gradient Categorization:

The Ellenberg values are used to assign species into broad habitat categories based on thresholds. For Light, species are categorized as belonging to "Forest" if the light value is less than 5, "Both" if the light value is between 5 (inclusive) and 8 (exclusive), and "Open" if the light value is 8 or higher. If the light value is missing, species are assigned to "Both."

For Nutrients, species are classified as "Poor" if the nutrients value is less than 5, "Both" if the nutrients value is between 5 (inclusive) and 8 (exclusive), and "Rich" if the nutrients value is 8 or higher. If the nutrients value is missing, species are assigned to "Both."

For Moisture, species are labeled as "Dry" if the moisture value is less than 4, "Both" if the moisture value is between 4 (inclusive) and 8 (exclusive), and "Wet" if the moisture value is 8 or higher. If the moisture value is missing, species are assigned to "Both."

## Habitat Assignment:

The code constructs compound habitat categories by combining the three dimensions:

Categories include combinations such as ForestDryPoor, OpenWetRich, etc.
If a species is categorized as "Both" in any dimension, it is duplicated across both relevant categories. For instance:

A species categorized as "Forest, Dry, Both (Nutrients)" would be assigned to both ForestDryPoor and ForestDryRich.

## Implementation

The following R code performs the habitat assignment:

```{r loadpackages}
# Load necessary libraries
library(dplyr)
library(tidyr)
library(readxl)
```


After that we read the dataset with the species atributed to for different habitats

```{r readellenberg}
# Read the Ellenberg table
ellenberg_table <- read_excel("EllembergTable.xlsx")
```

In table \@ref(tab:dimensionstable) we can see the first ten observations of the dataset as an example

```{r dimensionstable, echo = F}
knitr::kable(head(ellenberg_table, 10), caption = "Attributions of habitat dimensions based on ellenberg values")
```

We then generate a function to duplicate the rows for the Both Habitats

```{r Function}
# function to generate habitats
generate_habitats <- function(data) {
  # Define possible replacements for "Both"
  open_closed_vals <- c("Forest", "Open")
  rich_poor_vals <- c("Poor", "Rich")
  wet_dry_vals <- c("Dry", "Wet")

  # Replace "Both" with all possible combinations efficiently
  data %>%
    rowwise() %>%
    mutate(
      Open_Closed = list(if (Open_Closed == "Both") open_closed_vals else Open_Closed),
      Rich_Poor = list(if (Rich_Poor == "Both") rich_poor_vals else Rich_Poor),
      wet_dry = list(if (wet_dry == "Both") wet_dry_vals else wet_dry)
    ) %>%
    unnest_longer(Open_Closed) %>%
    unnest_longer(Rich_Poor) %>%
    unnest_longer(wet_dry) %>%
    mutate(Habitat = paste0(Open_Closed, wet_dry, Rich_Poor)) %>%
    select(-Open_Closed, -Rich_Poor, -wet_dry) %>%
    ungroup()
}
```

and then we use it to generate the new lookup table based on Ellenberg values

```{r generatehabitats}
# Generate the habitats
expanded_ellenberg_table <- generate_habitats(ellenberg_table) |>
  dplyr::mutate(Pres = 1) |>
  magrittr::set_colnames(c("species", "Landuse", "Pres"))
```


The output will include a new column, Habitat, that contains the compound habitat categories for each species, we can see the first ten rows of this new dataset in table \@ref(tab:newlookup).

```{r newlookup, echo = F}
knitr::kable(head(expanded_ellenberg_table, 10), caption = "New lookup table for habitats")
```

then we can write it out as a csv file

```{r writeLookup}
readr::write_csv(expanded_ellenberg_table, "Lookup.csv")
```



# Biodiversity estimation

## Partial usage of the SpeciesPoolR r package:

Here we already have a LookupTable as the one generated by the SpeciesPoolRPackage, here we wont need this, so we will use a simplified version of the workflow in order to create the necessary Biodiversity metrics (Rarity, Phylogenetic diversity and Species Richness), in order to do that we will use a workflow using some of the SpeciesPoolR functions, and the targets R package. In order to do that we first have to load the necessary packages

```{r WorkflowPackages}
library(targets)
library(SpeciesPoolR)
library(crew)
```


After this we run with targets a modified version of our prior workflow to include a precomputed lookup table instead of a modeled one

```{r targets, eval=FALSE}
targets::tar_option_set(
  packages = c("SpeciesPoolR", "data.table"),
  controller = crew::crew_controller_local(workers = 6),
  error = "null"
)

list(
  # Input file targets
  targets::tar_target(file, "EllembergTable.xlsx", format = "file"),
  targets::tar_target(data, get_data(file, filter = NULL)),
  targets::tar_target(shp, NULL, format = "file"),
  targets::tar_target(Raster, "Dir/LU.tif", format = "file"),
  targets::tar_target(Landusesuitability, "NewHabSut.tif", format = "file"),
  
  # Cleaning and processing data
  targets::tar_target(Clean, SpeciesPoolR::Clean_Taxa(data$Species)),
  targets::tar_target(
    Count_Presences,
    count_presences(Clean, country = "DK", shapefile = shp),
    pattern = map(Clean)
  ),
  targets::tar_target(
    More_than_zero,
    Count_Presences[N > 0, , by = species, sum(N)]
  ),
  targets::tar_target(
    Presences,
    get_presences(
      More_than_zero$species,
      country = "DK",
      shapefile = shp,
      limit = 10000
    ),
    pattern = map(More_than_zero)
  ),
  
  # Spatial processing
  targets::tar_target(
    buffer,
    make_buffer_rasterized(DT = Presences, file = Raster, dist = 500),
    pattern = map(Presences)
  ),
  
  # Lookup table
  targets::tar_target(LookUpFile, "Lookup.csv", format = "file"),
  targets::tar_target(LookUpTable, data.table::fread(LookUpFile)),
  
  # Land-use processing
  targets::tar_target(
    Long_LU_table,
    generate_long_landuse_table(path = Landusesuitability)
  ),
  targets::tar_target(
    Final_Presences,
    make_final_presences(Long_LU_table, buffer, LookUpTable)
  ),
  
  # Summary targets
  targets::tar_target(
    unique_species,
    unique(Final_Presences$species)
  ),
  targets::tar_target(
    unique_habitats,
    unique(Final_Presences$Landuse)
  ),
  
  # Export processed data
  targets::tar_target(
    export_presences,
    export_final_presences(
      Final_Presences[species == unique_species, ],
      folder = "Field_Final_Presences"
    ),
    pattern = map(unique_species),
    format = "file"
  ),
  
  # Phylogenetic and rarity calculations
  targets::tar_target(Phylo_Tree, generate_tree(More_than_zero)),
  targets::tar_target(rarity_weight, calc_rarity_weight(More_than_zero)),
  targets::tar_target(
    rarity,
    calc_rarity(
      Final_Presences[Landuse == unique_habitats, ],
      rarity_weight
    ),
    pattern = map(unique_habitats)
  ),
  targets::tar_target(
    PhyloDiversity,
    calc_pd(
      Final_Presences[Landuse == unique_habitats, ],
      Phylo_Tree
    ),
    pattern = map(unique_habitats)
  ),
  
  # Exporting results
  targets::tar_target(
    output_Rarity,
    export_rarity(Results = rarity, path = Raster),
    pattern = map(rarity),
    format = "file"
  ),
  targets::tar_target(
    output_Richness,
    export_richness(Results = PhyloDiversity, path = Raster),
    pattern = map(PhyloDiversity),
    format = "file"
  ),
  targets::tar_target(
    output_PD,
    export_pd(Results = PhyloDiversity, path = Raster),
    pattern = map(PhyloDiversity),
    format = "file"
  )
)

```

Here we can see a graphical implementation of the code

```{r codevisualization}
targets::tar_visnetwork()
```


# Biodiversity patterns

This results in three estimations of biodiversity, Species Richness, Phylogenetic diversity and Rarity, next we will explore the results of this calculated metrics.

## Species Richness

```{r plots}
library(terra)
library(tidyterra)
library(ggplot2)
```

In figure \@ref(fig:Richness) we see the patterns of species richness for all Habitats

```{r, Richness, echo = F, cache=TRUE, fig.cap= "Potential species richness for each of the habitat types"}
Richness <- list.files(path = "Results/Richness/", pattern = ".tif$", full.names = T) |> terra::rast()

ggplot2::ggplot() +
  geom_spatraster(data = Richness, maxcell = 3000000) +
  ggplot2::facet_wrap(~lyr) +
  scale_fill_wiki_c(direction = -1) +
  ggplot2::theme_dark()
```

In figure \@ref(fig:RichnessOWP) we see a more detail mode for open wet poor specifically to have a closer look at the details

```{r, RichnessOWP, echo = F, cache=TRUE, fig.cap= "Potential species richness for each Open Wet Rich"}
Richness <- list.files(path = "Results/Richness/", pattern = ".tif$", full.names = T) |> terra::rast()

ggplot2::ggplot() +
  geom_spatraster(data = Richness[[7]], maxcell = 3000000) +
  ggplot2::facet_wrap(~lyr) +
  scale_fill_wiki_c(direction = -1) +
  ggplot2::theme_dark()
```

## Phylogenetic diversity


```{r, PD, echo = F, cache=TRUE, fig.cap= "Potential phylogenetic diversity for each of the habitat types"}
PD <- list.files(path = "Results/PD/", pattern = ".tif$", full.names = T) |> terra::rast()

ggplot2::ggplot() +
  geom_spatraster(data = PD, maxcell = 3000000) +
  ggplot2::facet_wrap(~lyr) +
  scale_fill_wiki_c(direction = -1) +
  ggplot2::theme_dark()
```

## Rarity


```{r, Rarity, echo = F, cache=TRUE, fig.cap= "Potential rarity for each of the habitat types"}
Rarity <- list.files(path = "Results/Rarity/", pattern = ".tif$", full.names = T) |> terra::rast()

ggplot2::ggplot() +
  geom_spatraster(data = Rarity, maxcell = 3000000) +
  ggplot2::facet_wrap(~lyr) +
  scale_fill_wiki_c(direction = -1) +
  ggplot2::theme_dark()
```

# References
